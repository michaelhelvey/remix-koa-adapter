import type { AppLoadContext, ServerBuild } from '@remix-run/node'
import {
	createReadableStreamFromReadable,
	createRequestHandler as createRemixRequestHandler,
	writeReadableStreamToWritable,
} from '@remix-run/node'
import type * as koa from 'koa'

/**
 * A function that returns the value to use as `context` in route `loader` and
 * `action` functions.
 *
 * You can think of this as an escape hatch that allows you to pass
 * environment/platform-specific values through to your loader/action, such as
 * values that are generated by koa middleware.
 */
export type GetLoadContextFunction = (ctx: koa.Context) => AppLoadContext

export type RequestHandler = koa.Middleware

export type RequestHandlerBuilderArgs = {
	build: ServerBuild
	getLoadContext?: GetLoadContextFunction
	mode?: string
}

/**
 * Returns a request handler for koa that serves the response using Remix.
 *
 * @see https://remix.run/docs/en/main/other-api/adapter
 */
export function createRequestHandler({
	build,
	getLoadContext,
	mode = process.env.NODE_ENV,
}: RequestHandlerBuilderArgs): RequestHandler {
	const handleRequest = createRemixRequestHandler(build, mode)

	return async (ctx: koa.Context, next: koa.Next) => {
		const request = createRemixRequest(ctx)
		const loadContext = getLoadContext?.(ctx)

		const response = await handleRequest(request, loadContext)

		await sendRemixResponse(ctx, response)

		return next()
	}
}

export function createRemixHeaders(
	requestHeaders: koa.Request['headers']
): Headers {
	const headers = new Headers()

	for (const [key, values] of Object.entries(requestHeaders)) {
		if (values) {
			if (Array.isArray(values)) {
				for (const value of values) {
					headers.append(key, value)
				}
			} else {
				headers.set(key, values)
			}
		}
	}

	return headers
}

export function createRemixRequest(ctx: koa.Context): Request {
	const origin = `${ctx.protocol}://${ctx.host}`
	const url = new URL(ctx.url, origin)

	// Abort action/loaders once we can no longer write a response
	const controller = new AbortController()
	ctx.res.on('close', () => controller.abort())

	const init: RequestInit = {
		method: ctx.method,
		headers: createRemixHeaders(ctx.headers),
		// Cast until reason/throwIfAborted added
		// https://github.com/mysticatea/abort-controller/issues/36
		signal: controller.signal,
	}

	if (ctx.method !== 'GET' && ctx.method !== 'HEAD') {
		init.body = createReadableStreamFromReadable(ctx.req)
	}

	return new Request(url.href, init)
}

export async function sendRemixResponse(
	ctx: koa.Context, // write to
	nodeResponse: Response // read from
): Promise<void> {
	ctx.status = nodeResponse.status
	ctx.message = nodeResponse.statusText

	for (const [key, value] of nodeResponse.headers.entries()) {
		ctx.append(key, value)
	}

	if (nodeResponse.body) {
		await writeReadableStreamToWritable(nodeResponse.body, ctx.res)
	}
}
